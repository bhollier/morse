package morse

import (
	"bufio"
	"errors"
)

// Scanner is similar to bufio.Scanner but for Morse Signal,
// where it scans for tokens defined by a SplitFunc
type Scanner struct {
	// Use a bufio.Scanner instead of reinventing the wheel
	byteScanner *bufio.Scanner
}

// SplitFunc is the Morse Signal equivalent of bufio.SplitFunc
type SplitFunc func(data []Signal, atEOF bool) (advance int, token []Signal, err error)

// Errors returned by Scanner.
var (
	ErrTooLong         = errors.New("morse.Scanner: token too long")
	ErrNegativeAdvance = errors.New("morse.Scanner: SplitFunc returns negative advance count")
	ErrAdvanceTooFar   = errors.New("morse.Scanner: SplitFunc returns advance count beyond input")
	ErrBadReadCount    = errors.New("morse.Scanner: Read returned impossible count")
)

// NewScanner returns a new Scanner to read from r.
// The split function defaults to ScanWords.
func NewScanner(r Reader) Scanner {
	s := Scanner{
		byteScanner: bufio.NewScanner(ToByteReader{r}),
	}
	s.Split(ScanWords)
	return s
}

// Err returns the first non-EOF error that was encountered by the Scanner.
func (s Scanner) Err() error {
	switch defaultErr := s.byteScanner.Err(); defaultErr {
	case bufio.ErrTooLong:
		return ErrTooLong
	case bufio.ErrNegativeAdvance:
		return ErrNegativeAdvance
	case bufio.ErrAdvanceTooFar:
		return ErrAdvanceTooFar
	case bufio.ErrBadReadCount:
		return ErrBadReadCount
	default:
		return defaultErr
	}
}

// Signals returns the most recent token generated by a call to Scan.
// The underlying array may point to data that will be overwritten
// by a subsequent call to Scan. It does no allocation.
func (s Scanner) Signals() []Signal {
	return byteArrayToSignalArray(s.byteScanner.Bytes())
}

// Code is a convenience wrapper around Signals
func (s Scanner) Code() Code {
	return s.Signals()
}

// Scan advances the Scanner to the next token, which will then be
// available through the Signals or Code method. It returns false when the
// scan stops, either by reaching the end of the input or an error.
// After Scan returns false, the Err method will return any error that
// occurred during scanning, except that if it was io.EOF, Err
// will return nil.
// Scan panics if the split function returns too many empty
// tokens without advancing the input. This is a common error mode for
// scanners.
func (s Scanner) Scan() bool {
	return s.byteScanner.Scan()
}

// Buffer sets the initial buffer to use when scanning and the maximum
// size of buffer that may be allocated during scanning. The maximum
// token size is the larger of max and cap(buf). If max <= cap(buf),
// Scan will use this buffer only and do no allocation.
//
// By default, Scan uses an internal buffer and sets the
// maximum token size to MaxScanTokenSize.
//
// Buffer panics if it is called after scanning has started.
func (s Scanner) Buffer(buf []byte, max int) {
	s.byteScanner.Buffer(buf, max)
}

// Split sets the split function for the Scanner.
// The default split function is ScanWords.
//
// Split panics if it is called after scanning has started.
func (s Scanner) Split(split SplitFunc) {
	s.byteScanner.Split(func(data []byte, atEOF bool) (int, []byte, error) {
		advance, signalsToken, err := split(byteArrayToSignalArray(data), atEOF)
		return advance, signalArrayToByteArray(signalsToken), err
	})
}

// Split functions

// ScanSignals is a split function for a Scanner that returns each signal as a token.
func ScanSignals(data []Signal, atEOF bool) (advance int, token []Signal, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	return 1, data[0:1], nil
}

// ScanByDelimiter is a general purpose split function to split by a given Signal delimiter
func ScanByDelimiter(data []Signal, atEOF bool, delimiter Signal) (advance int, token []Signal, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	for i, s := range data {
		if s == delimiter ||
			// If the delimiter and signal is inaudible, check if the dit duration is larger,
			// so we still delimit if e.g. the delimiter is RuneSpace and we find WordSpace
			(!delimiter.Audible() && !s.Audible() && s.DitDuration() >= delimiter.DitDuration()) {
			return i + 1, data[0:i], nil
		}
	}
	// If we're at EOF, we have a final, non-terminated line. Return it.
	if atEOF {
		return len(data), data, nil
	}
	// Request more data.
	return 0, nil, nil
}

// ScanAudible is a split function for a Scanner that returns
// a string of audible Signals (usually just one) between
// SignalSpace
func ScanAudible(data []Signal, atEOF bool) (advance int, token []Signal, err error) {
	return ScanByDelimiter(data, atEOF, SignalSpace)
}

// ScanRunes is a split function for a Scanner that returns a
// string of Signals between RuneSpace
func ScanRunes(data []Signal, atEOF bool) (advance int, token []Signal, err error) {
	return ScanByDelimiter(data, atEOF, RuneSpace)
}

// ScanWords is a split function for a Scanner that returns a
// string of Signals between WordSpace
func ScanWords(data []Signal, atEOF bool) (advance int, token []Signal, err error) {
	return ScanByDelimiter(data, atEOF, WordSpace)
}
